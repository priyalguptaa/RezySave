import {
  ThemeProvider_default,
  nested_default,
  useTheme
} from "./chunk-7F77EHYS.js";
import {
  chainPropTypes,
  exactProp,
  init_utils,
  ponyfillGlobal_default
} from "./chunk-U2ESIHNB.js";
import {
  capitalize,
  clsx_default,
  deepmerge,
  getDisplayName,
  init_clsx
} from "./chunk-PKLGYWQW.js";
import {
  require_jsx_runtime
} from "./chunk-HSESELKR.js";
import {
  SheetsRegistry,
  createJss,
  getDynamicStyles,
  init_jss_esm,
  init_jss_plugin_camel_case_esm,
  init_jss_plugin_default_unit_esm,
  init_jss_plugin_global_esm,
  init_jss_plugin_nested_esm,
  init_jss_plugin_props_sort_esm,
  init_jss_plugin_rule_value_function_esm,
  init_jss_plugin_vendor_prefixer_esm,
  jss_plugin_camel_case_esm_default,
  jss_plugin_default_unit_esm_default,
  jss_plugin_global_esm_default,
  jss_plugin_nested_esm_default,
  jss_plugin_props_sort_esm_default,
  jss_plugin_rule_value_function_esm_default,
  jss_plugin_vendor_prefixer_esm_default
} from "./chunk-OWW4FQB7.js";
import "./chunk-ZXEKLRFZ.js";
import "./chunk-PL645EMI.js";
import {
  _extends,
  _objectWithoutPropertiesLoose,
  init_extends,
  init_objectWithoutPropertiesLoose,
  require_hoist_non_react_statics_cjs
} from "./chunk-YUEDO7DI.js";
import {
  require_prop_types
} from "./chunk-KIANZ5XW.js";
import {
  __toESM,
  require_react
} from "./chunk-YJNMHHGL.js";

// node_modules/@mui/styles/index.js
init_utils();

// node_modules/@mui/styles/createGenerateClassName/createGenerateClassName.js
var stateClasses = ["checked", "disabled", "error", "focused", "focusVisible", "required", "expanded", "selected"];
function createGenerateClassName(options = {}) {
  const {
    disableGlobal = false,
    productionPrefix = "jss",
    seed = ""
  } = options;
  const seedPrefix = seed === "" ? "" : `${seed}-`;
  let ruleCounter = 0;
  const getNextCounterId = () => {
    ruleCounter += 1;
    if (true) {
      if (ruleCounter >= 1e10) {
        console.warn(["MUI: You might have a memory leak.", "The ruleCounter is not supposed to grow that much."].join(""));
      }
    }
    return ruleCounter;
  };
  return (rule, styleSheet) => {
    const name = styleSheet.options.name;
    if (name && name.indexOf("Mui") === 0 && !styleSheet.options.link && !disableGlobal) {
      if (stateClasses.indexOf(rule.key) !== -1) {
        return `Mui-${rule.key}`;
      }
      const prefix = `${seedPrefix}${name}-${rule.key}`;
      if (!styleSheet.options.theme[nested_default] || seed !== "") {
        return prefix;
      }
      return `${prefix}-${getNextCounterId()}`;
    }
    if (false) {
      return `${seedPrefix}${productionPrefix}${getNextCounterId()}`;
    }
    const suffix = `${rule.key}-${getNextCounterId()}`;
    if (styleSheet.options.classNamePrefix) {
      return `${seedPrefix}${styleSheet.options.classNamePrefix}-${suffix}`;
    }
    return `${seedPrefix}${suffix}`;
  };
}

// node_modules/@mui/styles/createStyles/createStyles.js
function createStyles(styles) {
  return styles;
}

// node_modules/@mui/styles/getThemeProps/getThemeProps.js
init_extends();
function getThemeProps(params) {
  const {
    theme,
    name,
    props
  } = params;
  if (!theme || !theme.components || !theme.components[name] || !theme.components[name].defaultProps) {
    return props;
  }
  const output = _extends({}, props);
  const defaultProps = theme.components[name].defaultProps;
  let propName;
  for (propName in defaultProps) {
    if (output[propName] === void 0) {
      output[propName] = defaultProps[propName];
    }
  }
  return output;
}

// node_modules/@mui/styles/jssPreset/jssPreset.js
init_jss_plugin_rule_value_function_esm();
init_jss_plugin_global_esm();
init_jss_plugin_nested_esm();
init_jss_plugin_camel_case_esm();
init_jss_plugin_default_unit_esm();
init_jss_plugin_vendor_prefixer_esm();
init_jss_plugin_props_sort_esm();
function jssPreset() {
  return {
    plugins: [
      jss_plugin_rule_value_function_esm_default(),
      jss_plugin_global_esm_default(),
      jss_plugin_nested_esm_default(),
      jss_plugin_camel_case_esm_default(),
      jss_plugin_default_unit_esm_default(),
      // Disable the vendor prefixer server-side, it does nothing.
      // This way, we can get a performance boost.
      // In the documentation, we are using `autoprefixer` to solve this problem.
      typeof window === "undefined" ? null : jss_plugin_vendor_prefixer_esm_default(),
      jss_plugin_props_sort_esm_default()
    ]
  };
}

// node_modules/@mui/styles/makeStyles/makeStyles.js
init_objectWithoutPropertiesLoose();
init_extends();
var React2 = __toESM(require_react());
init_jss_esm();

// node_modules/@mui/styles/mergeClasses/mergeClasses.js
init_extends();
init_utils();
function mergeClasses(options = {}) {
  const {
    baseClasses,
    newClasses,
    Component
  } = options;
  if (!newClasses) {
    return baseClasses;
  }
  const nextClasses = _extends({}, baseClasses);
  if (true) {
    if (typeof newClasses === "string") {
      console.error([`MUI: The value \`${newClasses}\` provided to the classes prop of ${getDisplayName(Component)} is incorrect.`, "You might want to use the className prop instead."].join("\n"));
      return baseClasses;
    }
  }
  Object.keys(newClasses).forEach((key) => {
    if (true) {
      if (!baseClasses[key] && newClasses[key]) {
        console.error([`MUI: The key \`${key}\` provided to the classes prop is not implemented in ${getDisplayName(Component)}.`, `You can only override one of the following: ${Object.keys(baseClasses).join(",")}.`].join("\n"));
      }
      if (newClasses[key] && typeof newClasses[key] !== "string") {
        console.error([`MUI: The key \`${key}\` provided to the classes prop is not valid for ${getDisplayName(Component)}.`, `You need to provide a non empty string instead of: ${newClasses[key]}.`].join("\n"));
      }
    }
    if (newClasses[key]) {
      nextClasses[key] = `${baseClasses[key]} ${newClasses[key]}`;
    }
  });
  return nextClasses;
}

// node_modules/@mui/styles/makeStyles/multiKeyStore.js
var multiKeyStore = {
  set: (cache, key1, key2, value) => {
    let subCache = cache.get(key1);
    if (!subCache) {
      subCache = /* @__PURE__ */ new Map();
      cache.set(key1, subCache);
    }
    subCache.set(key2, value);
  },
  get: (cache, key1, key2) => {
    const subCache = cache.get(key1);
    return subCache ? subCache.get(key2) : void 0;
  },
  delete: (cache, key1, key2) => {
    const subCache = cache.get(key1);
    subCache.delete(key2);
  }
};
var multiKeyStore_default = multiKeyStore;

// node_modules/@mui/styles/useTheme/index.js
function useTheme2() {
  var _privateTheme$$$mater;
  const privateTheme = useTheme();
  return (_privateTheme$$$mater = privateTheme == null ? void 0 : privateTheme.$$material) != null ? _privateTheme$$$mater : privateTheme;
}

// node_modules/@mui/styles/StylesProvider/StylesProvider.js
init_extends();
init_objectWithoutPropertiesLoose();
var React = __toESM(require_react());
var import_prop_types = __toESM(require_prop_types());
init_utils();
init_jss_esm();
var import_jsx_runtime = __toESM(require_jsx_runtime());
var _excluded = ["children", "injectFirst", "disableGeneration"];
var defaultJSS = createJss(jssPreset());
var defaultGenerateClassName = createGenerateClassName();
var defaultSheetsManager = /* @__PURE__ */ new Map();
var defaultOptions = {
  disableGeneration: false,
  generateClassName: defaultGenerateClassName,
  jss: defaultJSS,
  sheetsCache: null,
  sheetsManager: defaultSheetsManager,
  sheetsRegistry: null
};
var StylesContext = React.createContext(defaultOptions);
if (true) {
  StylesContext.displayName = "StylesContext";
}
var injectFirstNode;
function StylesProvider(props) {
  const {
    children,
    injectFirst = false,
    disableGeneration = false
  } = props, localOptions = _objectWithoutPropertiesLoose(props, _excluded);
  const outerOptions = React.useContext(StylesContext);
  const {
    generateClassName,
    jss,
    serverGenerateClassName,
    sheetsCache,
    sheetsManager,
    sheetsRegistry
  } = _extends({}, outerOptions, localOptions);
  if (true) {
    if (injectFirst && localOptions.jss) {
      console.error("MUI: You cannot use the jss and injectFirst props at the same time.");
    }
  }
  const value = React.useMemo(() => {
    const context = {
      disableGeneration,
      generateClassName,
      jss,
      serverGenerateClassName,
      sheetsCache,
      sheetsManager,
      sheetsRegistry
    };
    if (true) {
      if (typeof window === "undefined" && !context.sheetsManager) {
        console.error("MUI: You need to use the ServerStyleSheets API when rendering on the server.");
      }
    }
    if (true) {
      if (context.jss.options.insertionPoint && injectFirst) {
        console.error("MUI: You cannot use a custom insertionPoint and <StylesContext injectFirst> at the same time.");
      }
    }
    if (!context.jss.options.insertionPoint && injectFirst && typeof window !== "undefined") {
      if (!injectFirstNode) {
        const head = document.head;
        injectFirstNode = document.createComment("mui-inject-first");
        head.insertBefore(injectFirstNode, head.firstChild);
      }
      context.jss = createJss({
        plugins: jssPreset().plugins,
        insertionPoint: injectFirstNode
      });
    }
    return context;
  }, [injectFirst, disableGeneration, generateClassName, jss, serverGenerateClassName, sheetsCache, sheetsManager, sheetsRegistry]);
  return (0, import_jsx_runtime.jsx)(StylesContext.Provider, {
    value,
    children
  });
}
true ? StylesProvider.propTypes = {
  /**
   * Your component tree.
   */
  children: import_prop_types.default.node,
  /**
   * You can disable the generation of the styles with this option.
   * It can be useful when traversing the React tree outside of the HTML
   * rendering step on the server.
   * Let's say you are using react-apollo to extract all
   * the queries made by the interface server-side - you can significantly speed up the traversal with this prop.
   */
  disableGeneration: import_prop_types.default.bool,
  /**
   * JSS's class name generator.
   */
  generateClassName: import_prop_types.default.func,
  /**
   * By default, the styles are injected last in the <head> element of the page.
   * As a result, they gain more specificity than any other style sheet.
   * If you want to override MUI's styles, set this prop.
   */
  injectFirst: import_prop_types.default.bool,
  /**
   * JSS's instance.
   */
  jss: import_prop_types.default.object,
  /**
   * @ignore
   */
  serverGenerateClassName: import_prop_types.default.func,
  /**
   * @ignore
   *
   * Beta feature.
   *
   * Cache for the sheets.
   */
  sheetsCache: import_prop_types.default.object,
  /**
   * @ignore
   *
   * The sheetsManager is used to deduplicate style sheet injection in the page.
   * It's deduplicating using the (theme, styles) couple.
   * On the server, you should provide a new instance for each request.
   */
  sheetsManager: import_prop_types.default.object,
  /**
   * @ignore
   *
   * Collect the sheets.
   */
  sheetsRegistry: import_prop_types.default.object
} : void 0;
if (true) {
  true ? StylesProvider.propTypes = exactProp(StylesProvider.propTypes) : void 0;
}

// node_modules/@mui/styles/makeStyles/indexCounter.js
var indexCounter = -1e9;
function increment() {
  indexCounter += 1;
  if (true) {
    if (indexCounter >= 0) {
      console.warn(["MUI: You might have a memory leak.", "The indexCounter is not supposed to grow that much."].join("\n"));
    }
  }
  return indexCounter;
}

// node_modules/@mui/styles/getStylesCreator/getStylesCreator.js
init_extends();
init_utils();

// node_modules/@mui/styles/propsToClassKey/propsToClassKey.js
init_objectWithoutPropertiesLoose();
init_utils();
var _excluded2 = ["variant"];
function isEmpty(string) {
  return string.length === 0;
}
function propsToClassKey(props) {
  const {
    variant
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded2);
  let classKey = variant || "";
  Object.keys(other).sort().forEach((key) => {
    if (key === "color") {
      classKey += isEmpty(classKey) ? props[key] : capitalize(props[key]);
    } else {
      classKey += `${isEmpty(classKey) ? key : capitalize(key)}${capitalize(props[key].toString())}`;
    }
  });
  return classKey;
}

// node_modules/@mui/styles/getStylesCreator/noopTheme.js
var noopTheme = {};
var noopTheme_default = noopTheme;

// node_modules/@mui/styles/getStylesCreator/getStylesCreator.js
function getStylesCreator(stylesOrCreator) {
  const themingEnabled = typeof stylesOrCreator === "function";
  if (true) {
    if (typeof stylesOrCreator !== "object" && !themingEnabled) {
      console.error(["MUI: The `styles` argument provided is invalid.", "You need to provide a function generating the styles or a styles object."].join("\n"));
    }
  }
  return {
    create: (theme, name) => {
      let styles;
      try {
        styles = themingEnabled ? stylesOrCreator(theme) : stylesOrCreator;
      } catch (err) {
        if (true) {
          if (themingEnabled === true && theme === noopTheme_default) {
            console.error(["MUI: The `styles` argument provided is invalid.", "You are providing a function without a theme in the context.", "One of the parent elements needs to use a ThemeProvider."].join("\n"));
          }
        }
        throw err;
      }
      if (!name || !theme.components || !theme.components[name] || !theme.components[name].styleOverrides && !theme.components[name].variants) {
        return styles;
      }
      const overrides = theme.components[name].styleOverrides || {};
      const variants = theme.components[name].variants || [];
      const stylesWithOverrides = _extends({}, styles);
      Object.keys(overrides).forEach((key) => {
        if (true) {
          if (!stylesWithOverrides[key]) {
            console.warn(["MUI: You are trying to override a style that does not exist.", `Fix the \`${key}\` key of \`theme.components.${name}.styleOverrides\`.`, "", `If you intentionally wanted to add a new key, please use the theme.components[${name}].variants option.`].join("\n"));
          }
        }
        stylesWithOverrides[key] = deepmerge(stylesWithOverrides[key] || {}, overrides[key]);
      });
      variants.forEach((definition) => {
        const classKey = propsToClassKey(definition.props);
        stylesWithOverrides[classKey] = deepmerge(stylesWithOverrides[classKey] || {}, definition.style);
      });
      return stylesWithOverrides;
    },
    options: {}
  };
}

// node_modules/@mui/styles/makeStyles/makeStyles.js
var _excluded3 = ["name", "classNamePrefix", "Component", "defaultTheme"];
function getClasses({
  state,
  stylesOptions
}, classes, Component) {
  if (stylesOptions.disableGeneration) {
    return classes || {};
  }
  if (!state.cacheClasses) {
    state.cacheClasses = {
      // Cache for the finalized classes value.
      value: null,
      // Cache for the last used classes prop pointer.
      lastProp: null,
      // Cache for the last used rendered classes pointer.
      lastJSS: {}
    };
  }
  let generate = false;
  if (state.classes !== state.cacheClasses.lastJSS) {
    state.cacheClasses.lastJSS = state.classes;
    generate = true;
  }
  if (classes !== state.cacheClasses.lastProp) {
    state.cacheClasses.lastProp = classes;
    generate = true;
  }
  if (generate) {
    state.cacheClasses.value = mergeClasses({
      baseClasses: state.cacheClasses.lastJSS,
      newClasses: classes,
      Component
    });
  }
  return state.cacheClasses.value;
}
function attach({
  state,
  theme,
  stylesOptions,
  stylesCreator,
  name
}, props) {
  if (stylesOptions.disableGeneration) {
    return;
  }
  let sheetManager = multiKeyStore_default.get(stylesOptions.sheetsManager, stylesCreator, theme);
  if (!sheetManager) {
    sheetManager = {
      refs: 0,
      staticSheet: null,
      dynamicStyles: null
    };
    multiKeyStore_default.set(stylesOptions.sheetsManager, stylesCreator, theme, sheetManager);
  }
  const options = _extends({}, stylesCreator.options, stylesOptions, {
    theme,
    flip: typeof stylesOptions.flip === "boolean" ? stylesOptions.flip : theme.direction === "rtl"
  });
  options.generateId = options.serverGenerateClassName || options.generateClassName;
  const sheetsRegistry = stylesOptions.sheetsRegistry;
  if (sheetManager.refs === 0) {
    let staticSheet;
    if (stylesOptions.sheetsCache) {
      staticSheet = multiKeyStore_default.get(stylesOptions.sheetsCache, stylesCreator, theme);
    }
    const styles = stylesCreator.create(theme, name);
    if (!staticSheet) {
      staticSheet = stylesOptions.jss.createStyleSheet(styles, _extends({
        link: false
      }, options));
      staticSheet.attach();
      if (stylesOptions.sheetsCache) {
        multiKeyStore_default.set(stylesOptions.sheetsCache, stylesCreator, theme, staticSheet);
      }
    }
    if (sheetsRegistry) {
      sheetsRegistry.add(staticSheet);
    }
    sheetManager.staticSheet = staticSheet;
    sheetManager.dynamicStyles = getDynamicStyles(styles);
  }
  if (sheetManager.dynamicStyles) {
    const dynamicSheet = stylesOptions.jss.createStyleSheet(sheetManager.dynamicStyles, _extends({
      link: true
    }, options));
    dynamicSheet.update(props);
    dynamicSheet.attach();
    state.dynamicSheet = dynamicSheet;
    state.classes = mergeClasses({
      baseClasses: sheetManager.staticSheet.classes,
      newClasses: dynamicSheet.classes
    });
    if (sheetsRegistry) {
      sheetsRegistry.add(dynamicSheet);
    }
  } else {
    state.classes = sheetManager.staticSheet.classes;
  }
  sheetManager.refs += 1;
}
function update({
  state
}, props) {
  if (state.dynamicSheet) {
    state.dynamicSheet.update(props);
  }
}
function detach({
  state,
  theme,
  stylesOptions,
  stylesCreator
}) {
  if (stylesOptions.disableGeneration) {
    return;
  }
  const sheetManager = multiKeyStore_default.get(stylesOptions.sheetsManager, stylesCreator, theme);
  sheetManager.refs -= 1;
  const sheetsRegistry = stylesOptions.sheetsRegistry;
  if (sheetManager.refs === 0) {
    multiKeyStore_default.delete(stylesOptions.sheetsManager, stylesCreator, theme);
    stylesOptions.jss.removeStyleSheet(sheetManager.staticSheet);
    if (sheetsRegistry) {
      sheetsRegistry.remove(sheetManager.staticSheet);
    }
  }
  if (state.dynamicSheet) {
    stylesOptions.jss.removeStyleSheet(state.dynamicSheet);
    if (sheetsRegistry) {
      sheetsRegistry.remove(state.dynamicSheet);
    }
  }
}
function useSynchronousEffect(func, values) {
  const key = React2.useRef([]);
  let output;
  const currentKey = React2.useMemo(() => ({}), values);
  if (key.current !== currentKey) {
    key.current = currentKey;
    output = func();
  }
  React2.useEffect(
    () => () => {
      if (output) {
        output();
      }
    },
    [currentKey]
    // eslint-disable-line react-hooks/exhaustive-deps
  );
}
function makeStyles(stylesOrCreator, options = {}) {
  const {
    // alias for classNamePrefix, if provided will listen to theme (required for theme.components[name].styleOverrides)
    name,
    // Help with debuggability.
    classNamePrefix: classNamePrefixOption,
    Component,
    defaultTheme = noopTheme_default
  } = options, stylesOptions2 = _objectWithoutPropertiesLoose(options, _excluded3);
  const stylesCreator = getStylesCreator(stylesOrCreator);
  const classNamePrefix = name || classNamePrefixOption || "makeStyles";
  stylesCreator.options = {
    index: increment(),
    name,
    meta: classNamePrefix,
    classNamePrefix
  };
  const useStyles = (props = {}) => {
    const theme = useTheme2() || defaultTheme;
    const stylesOptions = _extends({}, React2.useContext(StylesContext), stylesOptions2);
    const instance = React2.useRef();
    const shouldUpdate = React2.useRef();
    useSynchronousEffect(() => {
      const current = {
        name,
        state: {},
        stylesCreator,
        stylesOptions,
        theme
      };
      attach(current, props);
      shouldUpdate.current = false;
      instance.current = current;
      return () => {
        detach(current);
      };
    }, [theme, stylesCreator]);
    React2.useEffect(() => {
      if (shouldUpdate.current) {
        update(instance.current, props);
      }
      shouldUpdate.current = true;
    });
    const classes = getClasses(instance.current, props.classes, Component);
    if (true) {
      React2.useDebugValue(classes);
    }
    if (true) {
      const supportedComponents = ["MuiAvatar", "MuiBadge", "MuiButton", "MuiButtonGroup", "MuiChip", "MuiDivider", "MuiFab", "MuiPaper", "MuiToolbar", "MuiTypography", "MuiAlert", "MuiPagination", "MuiPaginationItem", "MuiSkeleton", "MuiTimelineDot"];
      if (name && supportedComponents.indexOf(name) >= 0 && props.variant && !classes[props.variant]) {
        console.error([`MUI: You are using a variant value \`${props.variant}\` for which you didn't define styles.`, `Please create a new variant matcher in your theme for this variant. To learn more about matchers visit https://mui.com/r/custom-component-variants.`].join("\n"));
      }
    }
    return classes;
  };
  return useStyles;
}

// node_modules/@mui/styles/ServerStyleSheets/ServerStyleSheets.js
init_extends();
var React3 = __toESM(require_react());
init_jss_esm();
var import_jsx_runtime2 = __toESM(require_jsx_runtime());
var ServerStyleSheets = class {
  constructor(options = {}) {
    this.options = options;
  }
  collect(children) {
    const sheetsManager = /* @__PURE__ */ new Map();
    this.sheetsRegistry = new SheetsRegistry();
    const generateClassName = createGenerateClassName();
    return (0, import_jsx_runtime2.jsx)(StylesProvider, _extends({
      sheetsManager,
      serverGenerateClassName: generateClassName,
      sheetsRegistry: this.sheetsRegistry
    }, this.options, {
      children
    }));
  }
  toString() {
    return this.sheetsRegistry ? this.sheetsRegistry.toString() : "";
  }
  getStyleElement(props) {
    return React3.createElement("style", _extends({
      id: "jss-server-side",
      key: "jss-server-side",
      dangerouslySetInnerHTML: {
        __html: this.toString()
      }
    }, props));
  }
};

// node_modules/@mui/styles/styled/styled.js
init_extends();
init_objectWithoutPropertiesLoose();
var React4 = __toESM(require_react());
init_clsx();
var import_prop_types2 = __toESM(require_prop_types());
init_utils();
var import_hoist_non_react_statics = __toESM(require_hoist_non_react_statics_cjs());
var import_jsx_runtime3 = __toESM(require_jsx_runtime());
var _excluded4 = ["name"];
var _excluded22 = ["children", "className", "clone", "component"];
function omit(input, fields) {
  const output = {};
  Object.keys(input).forEach((prop) => {
    if (fields.indexOf(prop) === -1) {
      output[prop] = input[prop];
    }
  });
  return output;
}
function styled(Component) {
  const componentCreator = (style, options = {}) => {
    const {
      name
    } = options, stylesOptions = _objectWithoutPropertiesLoose(options, _excluded4);
    if (Component === void 0) {
      throw new Error(["You are calling styled(Component)(style) with an undefined component.", "You may have forgotten to import it."].join("\n"));
    }
    let classNamePrefix = name;
    if (true) {
      if (!name) {
        const displayName = getDisplayName(Component);
        if (displayName !== void 0) {
          classNamePrefix = displayName;
        }
      }
    }
    const stylesOrCreator = typeof style === "function" ? (theme) => ({
      root: (props) => style(_extends({
        theme
      }, props))
    }) : {
      root: style
    };
    const useStyles = makeStyles(stylesOrCreator, _extends({
      Component,
      name: name || Component.displayName,
      classNamePrefix
    }, stylesOptions));
    let filterProps;
    let propTypes = {};
    if (style.filterProps) {
      filterProps = style.filterProps;
      delete style.filterProps;
    }
    if (style.propTypes) {
      propTypes = style.propTypes;
      delete style.propTypes;
    }
    const StyledComponent = React4.forwardRef(function StyledComponent2(props, ref) {
      const {
        children,
        className: classNameProp,
        clone,
        component: ComponentProp
      } = props, other = _objectWithoutPropertiesLoose(props, _excluded22);
      const classes = useStyles(props);
      const className = clsx_default(classes.root, classNameProp);
      let spread = other;
      if (filterProps) {
        spread = omit(spread, filterProps);
      }
      if (clone) {
        return React4.cloneElement(children, _extends({
          className: clsx_default(children.props.className, className)
        }, spread));
      }
      if (typeof children === "function") {
        return children(_extends({
          className
        }, spread));
      }
      const FinalComponent = ComponentProp || Component;
      return (0, import_jsx_runtime3.jsx)(FinalComponent, _extends({
        ref,
        className
      }, spread, {
        children
      }));
    });
    true ? StyledComponent.propTypes = _extends({
      /**
       * A render function or node.
       */
      children: import_prop_types2.default.oneOfType([import_prop_types2.default.node, import_prop_types2.default.func]),
      /**
       * @ignore
       */
      className: import_prop_types2.default.string,
      /**
       * If `true`, the component will recycle it's children HTML element.
       * It's using `React.cloneElement` internally.
       *
       * This prop will be deprecated and removed in v5
       */
      clone: chainPropTypes(import_prop_types2.default.bool, (props) => {
        if (props.clone && props.component) {
          return new Error("You can not use the clone and component prop at the same time.");
        }
        return null;
      }),
      /**
       * The component used for the root node.
       * Either a string to use a HTML element or a component.
       */
      component: import_prop_types2.default.elementType
    }, propTypes) : void 0;
    if (true) {
      StyledComponent.displayName = `Styled(${classNamePrefix})`;
    }
    (0, import_hoist_non_react_statics.default)(StyledComponent, Component);
    return StyledComponent;
  };
  return componentCreator;
}

// node_modules/@mui/styles/useThemeVariants/useThemeVariants.js
var useThemeVariants = (props, name) => {
  const {
    classes = {}
  } = props;
  const theme = useTheme2();
  let variantsClasses = "";
  if (theme && theme.components && theme.components[name] && theme.components[name].variants) {
    const themeVariants = theme.components[name].variants;
    themeVariants.forEach((themeVariant) => {
      let isMatch = true;
      Object.keys(themeVariant.props).forEach((key) => {
        if (props[key] !== themeVariant.props[key]) {
          isMatch = false;
        }
      });
      if (isMatch) {
        variantsClasses = `${variantsClasses}${classes[propsToClassKey(themeVariant.props)]} `;
      }
    });
  }
  return variantsClasses;
};
var useThemeVariants_default = useThemeVariants;

// node_modules/@mui/styles/withStyles/withStyles.js
init_extends();
init_objectWithoutPropertiesLoose();
var React5 = __toESM(require_react());
var import_prop_types3 = __toESM(require_prop_types());
var import_hoist_non_react_statics2 = __toESM(require_hoist_non_react_statics_cjs());
init_utils();
var import_jsx_runtime4 = __toESM(require_jsx_runtime());
var _excluded5 = ["defaultTheme", "withTheme", "name"];
var _excluded23 = ["classes"];
var withStyles = (stylesOrCreator, options = {}) => (Component) => {
  const {
    defaultTheme,
    withTheme: withTheme2 = false,
    name
  } = options, stylesOptions = _objectWithoutPropertiesLoose(options, _excluded5);
  if (true) {
    if (Component === void 0) {
      throw new Error(["You are calling withStyles(styles)(Component) with an undefined component.", "You may have forgotten to import it."].join("\n"));
    }
  }
  let classNamePrefix = name;
  if (true) {
    if (!name) {
      const displayName = getDisplayName(Component);
      if (displayName !== void 0) {
        classNamePrefix = displayName;
      }
    }
  }
  const useStyles = makeStyles(stylesOrCreator, _extends({
    defaultTheme,
    Component,
    name: name || Component.displayName,
    classNamePrefix
  }, stylesOptions));
  const WithStyles = React5.forwardRef(function WithStyles2(props, ref) {
    const other = _objectWithoutPropertiesLoose(props, _excluded23);
    const classes = useStyles(_extends({}, Component.defaultProps, props));
    let theme;
    let more = other;
    if (typeof name === "string" || withTheme2) {
      theme = useTheme2() || defaultTheme;
      if (name) {
        more = getThemeProps({
          theme,
          name,
          props: other
        });
      }
      if (withTheme2 && !more.theme) {
        more.theme = theme;
      }
    }
    return (0, import_jsx_runtime4.jsx)(Component, _extends({
      ref,
      classes
    }, more));
  });
  true ? WithStyles.propTypes = {
    /**
     * Override or extend the styles applied to the component.
     */
    classes: import_prop_types3.default.object
  } : void 0;
  if (true) {
    WithStyles.displayName = `WithStyles(${getDisplayName(Component)})`;
  }
  (0, import_hoist_non_react_statics2.default)(WithStyles, Component);
  if (true) {
    WithStyles.Naked = Component;
    WithStyles.options = options;
    WithStyles.useStyles = useStyles;
  }
  return WithStyles;
};
var withStyles_default = withStyles;

// node_modules/@mui/styles/withTheme/withTheme.js
init_extends();
var React6 = __toESM(require_react());
var import_hoist_non_react_statics3 = __toESM(require_hoist_non_react_statics_cjs());
init_utils();
var import_jsx_runtime5 = __toESM(require_jsx_runtime());
function withThemeCreator(options = {}) {
  const {
    defaultTheme
  } = options;
  const withTheme2 = (Component) => {
    if (true) {
      if (Component === void 0) {
        throw new Error(["You are calling withTheme(Component) with an undefined component.", "You may have forgotten to import it."].join("\n"));
      }
    }
    const WithTheme = React6.forwardRef(function WithTheme2(props, ref) {
      const theme = useTheme2() || defaultTheme;
      return (0, import_jsx_runtime5.jsx)(Component, _extends({
        theme,
        ref
      }, props));
    });
    if (true) {
      WithTheme.displayName = `WithTheme(${getDisplayName(Component)})`;
    }
    (0, import_hoist_non_react_statics3.default)(WithTheme, Component);
    if (true) {
      WithTheme.Naked = Component;
    }
    return WithTheme;
  };
  return withTheme2;
}
var withTheme = withThemeCreator();
var withTheme_default = withTheme;

// node_modules/@mui/styles/index.js
if (typeof window !== "undefined") {
  ponyfillGlobal_default["__@mui/styles-init__"] = ponyfillGlobal_default["__@mui/styles-init__"] || 0;
  if (ponyfillGlobal_default["__@mui/styles-init__"] === 1) {
    console.warn(["It looks like there are several instances of `@mui/styles` initialized in this application.", "This may cause theme propagation issues, broken class names, specificity issues, and makes your application bigger without a good reason.", "", "See https://mui.com/r/styles-instance-warning for more info."].join("\n"));
  }
  ponyfillGlobal_default["__@mui/styles-init__"] += 1;
}
export {
  ServerStyleSheets,
  StylesContext,
  StylesProvider,
  ThemeProvider_default as ThemeProvider,
  createGenerateClassName,
  createStyles,
  getThemeProps,
  jssPreset,
  makeStyles,
  mergeClasses,
  propsToClassKey,
  defaultSheetsManager as sheetsManager,
  styled,
  useTheme2 as useTheme,
  useThemeVariants_default as useThemeVariants,
  withStyles_default as withStyles,
  withTheme_default as withTheme,
  withThemeCreator
};
/*! Bundled license information:

@mui/styles/index.js:
  (**
   * @mui/styles v5.15.15
   *
   * @license MIT
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=@mui_styles.js.map
